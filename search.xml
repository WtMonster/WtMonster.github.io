<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MVCC与覆盖索引</title>
    <url>/2022/08/25/MVCC%E4%B8%8E%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>近期看到这样一个问题：<code>走覆盖索引不用回表，但是如何用MVCC判断可见性？因为二级索引上没有隐藏列trx_id和roll_ptr。而MVCC是基于trx_id和roll_ptr。那走覆盖索引如何判断是否可见呢?</code></p>
<span id="more"></span>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><blockquote>
<p>参考资料</p>
<p><a href="https://www.modb.pro/db/173167">https://www.modb.pro/db/173167</a></p>
<p><a href="https://www.zhihu.com/question/27674363/answer/38034982">https://www.zhihu.com/question/27674363/answer/38034982</a></p>
<p>《Innodb存储引擎》</p>
</blockquote>
<p><strong>以下讨论基于Innodb的RR隔离级别</strong></p>
<h4 id="聚簇索引行记录"><a href="#聚簇索引行记录" class="headerlink" title="聚簇索引行记录"></a>聚簇索引行记录</h4><p>根据《Innodb存储引擎》：InnoDB每行有隐藏列<strong>TransactionID</strong>和<strong>Roll Pointer</strong></p>
<p>其中TransactionID是用于记录修改该记录的最新事务id，<strong>用于MVCC判断可见性及回滚</strong>。</p>
<p>而Roll Pointer也就是回滚指针，用于配合undolog进行<strong>数据版本回溯</strong>。</p>
<h4 id="二级索引记录"><a href="#二级索引记录" class="headerlink" title="二级索引记录"></a>二级索引记录</h4><p>问题中提到二级索引上没有隐藏列trx_id和roll_ptr，这的确是正确的。</p>
<p>但二级索引的页面具有<strong>PAGE_MAX_TRX_ID</strong>，用于记录修改页内数据的最新事务id。</p>
<p><strong>所以</strong></p>
<p>如果PAGE_MAX_TRX_ID的值是在Read View创建前提交的，那么该页的全部索引都可见；</p>
<p>如果不是，则需要根据二级索引的主键进行回表，进行再次判断。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>二级索引的页面含有PAGE_MAX_TRX_ID用于记录修改页内数据的最新事务id，如果PAGE_MAX_TRX_ID的值是在Read View创建前提交的，那么该页的全部索引都可见；如果不是，则需要根据二级索引的主键进行回表，进行再次判断。</p>
<p>所以覆盖索引不是总不需要回表的。</p>
<h3 id="引申思考"><a href="#引申思考" class="headerlink" title="引申思考"></a>引申思考</h3><ul>
<li><p>为什么二级索引要选择存储页面最新的事务id，而非单条索引记录的最新事务id？</p>
<p>如果每条索引记录都存储最新事务id，那么可以减少不必要的回表，因为页内可能有一部分索引记录的最新事务是在当前事务创建之前提交的。</p>
<p>而以页面为单位存储最新事务id可以减少索引记录的数据量。</p>
<p>个人认为这是一种效率与空间之间的权衡。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>常量池详解</title>
    <url>/2022/06/25/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="关于常量池"><a href="#关于常量池" class="headerlink" title="关于常量池"></a>关于常量池</h2><h3 id="常量池-Class常量池（Constant-pool）"><a href="#常量池-Class常量池（Constant-pool）" class="headerlink" title="常量池/Class常量池（Constant pool）"></a>常量池/Class常量池（Constant pool）</h3><p>常量池,也叫 Class 常量池(常量池 == Class常量池)。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区 各种字面量 (Literal)和 符号引用 。</p>
<span id="more"></span>

<p><img src="image-20220825185951061.png" alt="image-20220825185951061"></p>
<h3 id="运行时常量池（Runtime-constant-pool）"><a href="#运行时常量池（Runtime-constant-pool）" class="headerlink" title="运行时常量池（Runtime constant pool）"></a>运行时常量池（Runtime constant pool）</h3><p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 **将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)**。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</p>
<p><strong>只存放字符串引用</strong></p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzM3MDY4,size_16,color_FFFFFF,t_70-16547411527242-166140658303417.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzM3MDY4,size_16,color_FFFFFF,t_70-16547411527242"></p>
<h3 id="字符串常量池（String-pool-String-table）"><a href="#字符串常量池（String-pool-String-table）" class="headerlink" title="字符串常量池（String pool/String table）"></a>字符串常量池（String pool/String table）</h3><p>字符串常量池逻辑上是运行时常量池的子集，具体可见<a href="https://github.com/fenixsoft/jvm_book/issues/112">https://github.com/fenixsoft/jvm_book/issues/112</a></p>
<p>字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool。 在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间：字符串常量池。<strong>字符串常量池由String类私有的维护</strong>。</p>
<h3 id="常量池和字符串常量池的版本变化"><a href="#常量池和字符串常量池的版本变化" class="headerlink" title="常量池和字符串常量池的版本变化"></a>常量池和字符串常量池的版本变化</h3><ul>
<li><p>在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</p>
</li>
<li><p>在JDK1.7 字符串常量池、静态变量等被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说 字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</p>
<blockquote>
<p>这里错了，字符串常量池并没有被移动，还是在native memory，移动的是String实例</p>
</blockquote>
</li>
<li><p>在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</p>
<blockquote>
<p>字符串常量池（StringTable）在native memory</p>
</blockquote>
</li>
<li><p>JDK1.8-1.9,String底层从char数组变成了byte数组，原因是部分字符仅占一个byte，而堆中含有大量的String字符串，该优化能节省较多空间。</p>
</li>
<li><p>补充：</p>
<ul>
<li>对象只能存在于堆中（虚拟机规范的定义），所以String实体只能存在于堆中</li>
<li>运行时常量池存放的是字面量引用</li>
<li>使用双引号方式显式声明的字符串，则直接放入字符串常量池中（final修饰的“变量”可以直接看作双引号字面量）</li>
</ul>
</li>
</ul>
<p><strong>StringTable为什么要调整</strong>（1.6-1.7）</p>
<ul>
<li>permSize默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
<p><strong>字符串拼接操作</strong></p>
<ul>
<li>常量与常量的拼接结果在常量池，原理是编译器优化</li>
<li>常量池中不会存在相同内容的常量</li>
<li>只要其中一个是变量，结果就在堆中。变量拼接的原理是StringBuilder（final不算变量），返回String对象</li>
<li>如果拼接的结果调用intern()方法，则注定将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ul>
<p><strong>所以建议多使用final定义字符串,并且不使用new，对于new String()声明final不会优化</strong></p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">IsInPool</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str == str.intern();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> a1 + a2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">limit1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">a4</span> <span class="operator">=</span> <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a5</span> <span class="operator">=</span> <span class="string">&quot;d&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a6</span> <span class="operator">=</span> a4 + a5;</span><br><span class="line">    <span class="type">String</span> <span class="variable">limit2</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">limit3</span> <span class="operator">=</span> <span class="string">&quot;ef&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b6</span> <span class="operator">=</span> b4 + b5;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">limit4</span> <span class="operator">=</span> <span class="string">&quot;gh&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(IsInPool(a3));<span class="comment">//true</span></span><br><span class="line">    System.out.println(IsInPool(a6));<span class="comment">//false</span></span><br><span class="line">    System.out.println(IsInPool(b3));<span class="comment">//false</span></span><br><span class="line">    System.out.println(IsInPool(b6));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<img src="image-20211008215003210.png" alt="image-20211008215003210" style="zoom:50%;">

<h2 id="字符串的创建与常量池"><a href="#字符串的创建与常量池" class="headerlink" title="字符串的创建与常量池"></a><strong>字符串的创建与常量池</strong></h2><p><strong>String两种创建方式</strong></p>
<ul>
<li>方式一（str值和字符串常量池中字面量地址相等）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>检查字符串常量池是否存在该字符串，存在则不创建并且返回string对象的引用</li>
<li>不存在则在堆中创建该字符串常量对应的string对象并将其引用存入字符串常量池中，然后返回该创建对象的引用</li>
</ol>
<ul>
<li>方式二（str值和字符串常量池中字面量地址不相等）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>检查字符串常量池是否存在该字符串，存在则不创建string对象,不存在则在堆中创建该字符串常量对应的string对象并将其引用存入字符串常量池中</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/classfile/symbolTable.cpp</span></span><br><span class="line"><span class="comment">// try to reuse the string if possible</span></span><br><span class="line"><span class="keyword">if</span> (!string_or_null.is_null()) &#123;</span><br><span class="line"> <span class="built_in">string</span> = string_or_null;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">string</span> = java_lang_String::create_from_unicode(name, len, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在堆中创建该对象，对象内部的char数组（实际的value）与常量池中创建的string对象共用一个char数组</p>
</li>
</ol>
<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">Field</span> <span class="variable">value</span> <span class="operator">=</span> str1.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">value.setAccessible(<span class="literal">true</span>);</span><br><span class="line">System.out.println(System.identityHashCode(str1));<span class="comment">//990368553</span></span><br><span class="line">System.out.println(System.identityHashCode(value.get(str1)));<span class="comment">//1096979270</span></span><br><span class="line">System.out.println(System.identityHashCode(value.get(str2)));<span class="comment">//1096979270</span></span><br><span class="line">System.out.println(System.identityHashCode(str2));<span class="comment">//1078694789</span></span><br><span class="line">System.out.println(System.identityHashCode(str1.intern()));<span class="comment">//1078694789</span></span><br></pre></td></tr></table></figure>

<p><strong>普遍地</strong></p>
<p>使用双引号方式显式存在的字符串，则直接放入字符串常量池中（final修饰的“变量”可以直接看作双引号字面量）</p>
<h3 id="一些测试（JDK1-8）"><a href="#一些测试（JDK1-8）" class="headerlink" title="一些测试（JDK1.8）"></a><strong>一些测试</strong>（JDK1.8）</h3><p>情况一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="string">&quot;c&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a4</span> <span class="operator">=</span> a1 + a2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a5</span> <span class="operator">=</span> a1 + a3;</span><br><span class="line"><span class="comment">//        String at = &quot;a&quot;+&quot;c&quot;;</span></span><br><span class="line"><span class="comment">//        String at1 = &quot;a&quot;+&quot;b&quot;;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(IsInPool(a1));<span class="comment">//true</span></span><br><span class="line">        System.out.println(IsInPool(<span class="string">&quot;b&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(IsInPool(a2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(IsInPool(a3));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(IsInPool(a4));<span class="comment">//true</span></span><br><span class="line">        System.out.println(IsInPool(<span class="string">&quot;ab&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(IsInPool(a5));<span class="comment">//true</span></span><br><span class="line">        System.out.println(IsInPool(<span class="string">&quot;ac&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>情况二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a4</span> <span class="operator">=</span> a1 + a2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a5</span> <span class="operator">=</span> a1 + a3;</span><br><span class="line">    <span class="type">String</span> <span class="variable">at</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>+<span class="string">&quot;c&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">at1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(IsInPool(a1));<span class="comment">//true</span></span><br><span class="line">    System.out.println(IsInPool(<span class="string">&quot;b&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(IsInPool(a2));<span class="comment">//false</span></span><br><span class="line">    System.out.println(IsInPool(a3));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    System.out.println(IsInPool(a4));<span class="comment">//false</span></span><br><span class="line">    System.out.println(IsInPool(<span class="string">&quot;ab&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(IsInPool(a5));<span class="comment">//false</span></span><br><span class="line">    System.out.println(IsInPool(<span class="string">&quot;ac&quot;</span>));<span class="comment">//t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IsInpool函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//使用这个函数需要在这个函数前使用双引号字面量使得字符串直接被加入常量池中</span></span><br><span class="line"><span class="comment">//使用顺序应为待测字符串-&gt;字面量-&gt;IsInPool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">IsInPool</span><span class="params">(String str)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> str == str.intern();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="对于intern函数的理解"><a href="#对于intern函数的理解" class="headerlink" title="对于intern函数的理解"></a>对于intern函数的理解</h3><p>调用这个方法之后就是去看当前字符串是否在字符串常量池中已经存在引用</p>
<p>（1）<strong>存 在</strong>：那就直接返回该字符串在字符串常量池中所对应的地址给栈中要引用这个字符串的变量。</p>
<p>（2）<strong>不存在</strong>：<br>① jdk 1.6：先在字符串常量池中创建该字符串，地址与堆中字符串地址不相同（方法区）。然后再返回刚创建的字符串在字符串常量池中所对应的地址给栈中要引用这个字符串的变量。</p>
<p>② jdk 1.7及以后：直接将堆中（不是字符串常量池中）该字符串的地址复制到字符串常量池中，这样字符串常量池就有了该字符串的地址引用，也可以说此时字符串常量池中的字符串只是一个对堆中字符串对象的引用，它们两个的地址相同，然后再把这个地址返回给栈中要引用这个字符串的变量。</p>
<blockquote>
<p>具体看下面源码解析，这里描述可能不太精确</p>
</blockquote>
<h3 id="对测试的解释"><a href="#对测试的解释" class="headerlink" title="对测试的解释"></a>对测试的解释</h3><ul>
<li>第一次两个拼接测试为true，因为intern函数将堆中字符串对象引用复制到字符串常量池中，所以二者自然相等</li>
<li>第二次两个拼接测试为false，因为intern检查到已经存在该字符常量，且堆常量池中保存的是字符串的值，二者自然不相等</li>
</ul>
<h3 id="对StringBuilder的优化"><a href="#对StringBuilder的优化" class="headerlink" title="对StringBuilder的优化"></a>对StringBuilder的优化</h3><p>对于StringBuilder.append,底层默认为长度为16的char型数组，超出长度则需要新建数组重新依次赋值</p>
<p>如果明确知道长度不高于某个值，可以使用new StringBuilder(max)来初始化 </p>
<h2 id="String的不可变性与强制修改"><a href="#String的不可变性与强制修改" class="headerlink" title="String的不可变性与强制修改"></a>String的不可变性与强制修改</h2><h3 id="String为什么不可变？"><a href="#String为什么不可变？" class="headerlink" title="String为什么不可变？"></a>String为什么不可变？</h3><ul>
<li>因为String底层是private修饰的final类型的char数组</li>
</ul>
<blockquote>
<p>Java9之后改用byte数组，原因是部分字符仅占一个byte，而堆中含有大量的String字符串，该优化能节省较多空间。</p>
</blockquote>
<ul>
<li><p>value数组创建出来后本身长度不可变，final修饰后也不能修改为其他引用</p>
</li>
<li><p>并且String本身是final类，也就是不可被继承的</p>
</li>
</ul>
<p><strong>以上都是不考虑反射的说法</strong></p>
<h3 id="强制修改String"><a href="#强制修改String" class="headerlink" title="强制修改String"></a>强制修改String</h3><p><strong>通过反射可以修改String</strong></p>
<p><strong>两块测试代码块应独立测试，因为第一部分代码块的isInPool会对常量池造成影响</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInPool</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str == str.intern();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;String  of &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="string">&quot;String  of test&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于检测常量池字面量是否被修改</span></span><br><span class="line">    <span class="comment">//如果被修改，那么intern返回的应该是常量池中地址，跟对象地址应该不一样</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Reflect of &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3 + s4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Influential---修改常量池中对象</span></span><br><span class="line"><span class="comment">     * 如果修改了，那么等下检测时str == str.intern()肯定会是true，</span></span><br><span class="line"><span class="comment">     * 因为常量池中不存在修改后的字面量，所以intern返回的是对象本身</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;修改堆对象&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前地址:&quot;</span>+System.identityHashCode(s));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前值:&quot;</span>+s);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">value</span> <span class="operator">=</span> s.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    value.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] o = (<span class="type">char</span>[]) value.get(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射数据地址:&quot;</span>+System.identityHashCode(o));</span><br><span class="line">    o[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    o[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    o[<span class="number">2</span>] = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    o[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    o[<span class="number">4</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    o[<span class="number">5</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    o[<span class="number">6</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后地址:&quot;</span>+System.identityHashCode(s));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后值:&quot;</span>+s);</span><br><span class="line">    System.out.println(isInPool(s));<span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;地址:&quot;</span>+System.identityHashCode(s));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Influential---修改String对象</span></span><br><span class="line"><span class="comment">     * 如果修改了常量池中String字面量，那么等下检测时str == str.intern()应该要是false，</span></span><br><span class="line"><span class="comment">     * 因为常量池按理已经存在了修改后的字面量，所以intern返回的常量池中地址</span></span><br><span class="line"><span class="comment">     * 那么为什么会是true？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===============分割线===============&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;下面是修改常量池&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前地址:&quot;</span>+System.identityHashCode(origin));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前值:&quot;</span>+origin);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">value2</span> <span class="operator">=</span> origin.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    value2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] o2 = (<span class="type">char</span>[]) value2.get(origin);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射数据地址:&quot;</span>+System.identityHashCode(o2));</span><br><span class="line">    o2[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    o2[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    o2[<span class="number">2</span>] = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    o2[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    o2[<span class="number">4</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    o2[<span class="number">5</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    o2[<span class="number">6</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后地址:&quot;</span>+System.identityHashCode(origin));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后值:&quot;</span>+origin);</span><br><span class="line"></span><br><span class="line">    System.out.println(isInPool(s5));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于上面第二部分代码的解释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="string">&quot;String  of test&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于检测常量池字面量是否被修改</span></span><br><span class="line">    <span class="comment">//如果被修改，那么intern返回的应该是常量池中地址，跟对象地址应该不一样</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span><span class="string">&quot;Reflect of test&quot;</span>;</span><br><span class="line">    System.out.println(System.identityHashCode(s3));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Influential---修改String对象</span></span><br><span class="line"><span class="comment">     * 如果修改了常量池中String字面量，那么等下检测时str == str.intern()应该要是false，</span></span><br><span class="line"><span class="comment">     * 因为常量池按理已经存在了修改后的字面量，所以intern返回的常量池中地址</span></span><br><span class="line"><span class="comment">     * 那么为什么会是true？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===============分割线===============&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;下面是修改常量池&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前地址:&quot;</span> + System.identityHashCode(origin));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前值:&quot;</span> + origin);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">value2</span> <span class="operator">=</span> origin.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    value2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] o2 = (<span class="type">char</span>[]) value2.get(origin);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射数据地址:&quot;</span> + System.identityHashCode(o2));</span><br><span class="line">    o2[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    o2[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    o2[<span class="number">2</span>] = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    o2[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    o2[<span class="number">4</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    o2[<span class="number">5</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    o2[<span class="number">6</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后地址:&quot;</span> + System.identityHashCode(origin));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后值:&quot;</span> + origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时S3&quot;Reflect of test&quot;</span></span><br><span class="line">    <span class="comment">//origin为&quot;Reflect of test&quot;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;修改前常量池的string of reflect地址&quot;</span>+System.identityHashCode(s3));<span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;修改string of test产生的string of reflect地址&quot;</span>+System.identityHashCode(origin));<span class="comment">//true</span></span><br><span class="line">    String ss=<span class="string">&quot;Reflect of test&quot;</span>;</span><br><span class="line">    System.out.println(System.identityHashCode(ss));</span><br><span class="line"></span><br><span class="line">    String sss=<span class="string">&quot;String  of test&quot;</span>;</span><br><span class="line">    System.out.println(System.identityHashCode(sss));</span><br><span class="line">    System.out.println(origin);</span><br><span class="line">    System.out.println(sss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会导致最后声明的sss输出结果变成Reflect of test</p>
<p><img src="image-20220410235820491-166140589670210.png" alt="image-20220410235820491"></p>
<p><strong>原因是：</strong></p>
<p>字符串常量池底层其实是个hash表，这也很好地解释了字符串常量池检查重复的机制，查重能达到O(1)的复杂度。</p>
<p>将一个字符串值存入常量池时，会在将hash值，字符串数组作为kv存入查重的hash表中。</p>
<blockquote>
<p>引用对象实体内容修改以后hash表里面字面量还是没变。</p>
</blockquote>
<p>上面这句话是错误的解释，常量的操作主要是三种</p>
<ul>
<li>一方面是编译时会优化</li>
<li>一方面显示声明会自动加常量池</li>
<li>一方面即时编译器也会优化</li>
</ul>
<p>实际上图中的问题是编译期间将多个常量只创建了一份，也就是通过的是class常量池，并非通过字符串常量池去重。</p>
<p>不过通过字面量显示声明的常量创建还是会走常量池的（无论是第一次创建还是后续重复创建）。</p>
<p>测试的时候可以通过将常量分别在多个类中编写来避免这种编译期间的去重（并且使用-Xint指定节解释执行）。</p>
<p>SymbolTable底层是基于hashtable实现的，结构是数组+链表，当存储的数据足够多，遇到hash碰撞严重时（Hotspot触发rehash的条件是：查找一个字符串超过100次），是通过切换hash算法实现的。</p>
<h2 id="intern源码研究-JDK8"><a href="#intern源码研究-JDK8" class="headerlink" title="intern源码研究(JDK8)"></a>intern源码研究(JDK8)</h2><p><a href="https://blog.csdn.net/qq_19648191/article/details/117358082">https://blog.csdn.net/qq_19648191/article/details/117358082</a></p>
<p><a href="https://www.freesion.com/article/61901174982/">https://www.freesion.com/article/61901174982/</a></p>
<p><a href="https://blog.csdn.net/qq_33678688/article/details/89091930">https://blog.csdn.net/qq_33678688/article/details/89091930</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28973077">https://zhuanlan.zhihu.com/p/28973077</a></p>
<ol>
<li><p><code>hotspot/src/share/vm/prims/jvm.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String support ///////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JVM_ENTRY</span>(jstring, <span class="built_in">JVM_InternString</span>(JNIEnv *env, jstring str))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_InternString&quot;</span>);</span><br><span class="line">  JvmtiVMObjectAllocEventCollector oam;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  oop string = JNIHandles::<span class="built_in">resolve_non_null</span>(str);</span><br><span class="line">  oop result = StringTable::<span class="built_in">intern</span>(string, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> (jstring) JNIHandles::<span class="built_in">make_local</span>(env, result);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hotspot/src/share/vm/classfile/symbolTable.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">StringTable::intern</span><span class="params">(oop string, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (string == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="comment">// 创建string的句柄</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_string</span> <span class="params">(THREAD, string)</span></span>;</span><br><span class="line">  <span class="comment">// 转换成Unicode编码的玩意，这里似乎是重新开空间创建一个Unicode的字符串</span></span><br><span class="line">  <span class="comment">// 但是在后面这个Unicode字符串只用于计算哈希值和查找比对，除非下一个intern方法中发现句柄没有创建才会用到这个Unicode来创建句柄</span></span><br><span class="line">  jchar* chars = java_lang_String::<span class="built_in">as_unicode_string</span>(string, length,</span><br><span class="line">                                                     CHECK_NULL);</span><br><span class="line">  <span class="comment">// 调用最终的intern</span></span><br><span class="line">  oop result = <span class="built_in">intern</span>(h_string, chars, length, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hotspot/src/share/vm/classfile/symbolTable.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string是个handle，chars是转成了unicode的原字符串</span></span><br><span class="line"><span class="function">oop <span class="title">StringTable::intern</span><span class="params">(Handle string_or_null, jchar* name,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> len, TRAPS)</span> </span>&#123; y</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hashValue = <span class="built_in">hash_string</span>(name, len);</span><br><span class="line">  <span class="type">int</span> index = <span class="built_in">the_table</span>()-&gt;<span class="built_in">hash_to_index</span>(hashValue);</span><br><span class="line">  oop found_string = <span class="built_in">the_table</span>()-&gt;<span class="built_in">lookup</span>(index, name, len, hashValue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Found</span></span><br><span class="line">  <span class="keyword">if</span> (found_string != <span class="literal">NULL</span>) <span class="keyword">return</span> found_string;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">debug_only</span>(StableMemoryChecker <span class="built_in">smc</span>(name, len * <span class="built_in">sizeof</span>(name[<span class="number">0</span>])));</span><br><span class="line">  <span class="built_in">assert</span>(!Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved</span>(name),</span><br><span class="line">         <span class="string">&quot;proposed name of symbol must be stable&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Handle string;</span><br><span class="line">  <span class="comment">// try to reuse the string if possible</span></span><br><span class="line">  <span class="comment">// 如果这个句柄已经创建好了能直接用那就直接用</span></span><br><span class="line">  <span class="keyword">if</span> (!string_or_null.<span class="built_in">is_null</span>()) &#123;</span><br><span class="line">    string = string_or_null;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果句柄没有创建好那就从转为Unicode编码后的这个字符串创建一个句柄</span></span><br><span class="line">    <span class="comment">// 目前看来似乎是编译期间使用双引号创建字面量会走这个逻辑，字符串常量池会直接创建一个string</span></span><br><span class="line">    string = java_lang_String::<span class="built_in">create_from_unicode</span>(name, len, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grab the StringTable_lock before getting the_table() because it could</span></span><br><span class="line">  <span class="comment">// change at safepoint.</span></span><br><span class="line">  <span class="function">MutexLocker <span class="title">ml</span><span class="params">(StringTable_lock, THREAD)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, add to symbol to table</span></span><br><span class="line">  <span class="comment">// 向stringtable里面添加句柄</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">the_table</span>()-&gt;<span class="built_in">basic_add</span>(index, string, name, len,</span><br><span class="line">                                hashValue, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hotspot/src/share/vm/classfile/symbolTable.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">oop <span class="title">StringTable::basic_add</span><span class="params">(<span class="type">int</span> index_arg, Handle string, jchar* name,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span> hashValue_arg, TRAPS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(java_lang_String::<span class="built_in">equals</span>(<span class="built_in">string</span>(), name, len),</span><br><span class="line">         <span class="string">&quot;string must be properly initialized&quot;</span>);</span><br><span class="line">  <span class="comment">// Cannot hit a safepoint in this function because the &quot;this&quot; pointer can move.</span></span><br><span class="line">  No_Safepoint_Verifier nsv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the symbol table has been rehashed, if so, need to recalculate</span></span><br><span class="line">  <span class="comment">// the hash value and index before second lookup.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hashValue;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">use_alternate_hashcode</span>()) &#123;</span><br><span class="line">    hashValue = <span class="built_in">hash_string</span>(name, len);</span><br><span class="line">    index = <span class="built_in">hash_to_index</span>(hashValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hashValue = hashValue_arg;</span><br><span class="line">    index = index_arg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since look-up was done lock-free, we need to check if another</span></span><br><span class="line">  <span class="comment">// thread beat us in the race to insert the symbol.</span></span><br><span class="line">  <span class="comment">// 如果已经有了就不用添加了并且可以直接返回</span></span><br><span class="line">  oop test = <span class="built_in">lookup</span>(index, name, len, hashValue); <span class="comment">// calls lookup(u1*, int)</span></span><br><span class="line">  <span class="keyword">if</span> (test != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Entry already added</span></span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// HashtableEntry 里面保存hash值以及这个字符串的引用（_literal），有了引用就可以得到字符串的字面量和地址了</span></span><br><span class="line">  HashtableEntry&lt;oop, mtSymbol&gt;* entry = <span class="built_in">new_entry</span>(hashValue, <span class="built_in">string</span>());</span><br><span class="line">  <span class="built_in">add_entry</span>(index, entry);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><p><strong>关于内存分配位置</strong></p>
<ol>
<li><p><code>hotspot/src/share/vm/runtime/handles.inline.hpp</code></p>
<p>句柄的创建用的是线程本地内存，也就是堆空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="title function_">Handle::Handle</span><span class="params">(Thread* thread, oop obj)</span> &#123;</span><br><span class="line">  assert(thread == Thread::current(), <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    _handle = <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _handle = thread-&gt;handle_area()-&gt;allocate_handle(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hotspot/src/share/vm/classfile/symbolTable.cpp</code></p>
<p>Unicode字符串的创建也是用的堆空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jchar* <span class="title function_">java_lang_String::as_unicode_string</span><span class="params">(oop java_string, <span class="type">int</span>&amp; length, TRAPS)</span> &#123;</span><br><span class="line">  typeArrayOop value  = java_lang_String::value(java_string);</span><br><span class="line">  <span class="type">int</span>          offset = java_lang_String::offset(java_string);</span><br><span class="line">               length = java_lang_String::length(java_string);</span><br><span class="line"></span><br><span class="line">  jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      result[index] = value-&gt;char_at(index + offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), <span class="string">&quot;could not allocate Unicode string&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hotspot/src/share/vm/memory/allocation.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEW_RESOURCE_ARRAY_RETURN_NULL(type, size)\</span></span><br><span class="line"><span class="meta">  (type*) resource_allocate_bytes((size) * sizeof(type), AllocFailStrategy::RETURN_NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hotspot/src/share/vm/memory/resourceArea.cpp</span></span><br><span class="line"><span class="comment">// Allocation in thread-local resource area</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>* <span class="title function_">resource_allocate_bytes</span><span class="params">(<span class="type">size_t</span> size, AllocFailType alloc_failmode)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Thread::current()-&gt;resource_area()-&gt;allocate_bytes(size, alloc_failmode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StringTable的创建实际上是在nativememory</p>
<ol>
<li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/enhancements-7.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/enhancements-7.html</a></p>
<p>官方文档说明说的是将interned strings移到堆内存中，而非StringTable</p>
<blockquote>
<p><strong>Area</strong>: HotSpot<br><strong>Standard/Platform</strong>: JDK 7<br><strong>Synopsis</strong>: In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and lessw data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the <code>String.intern()</code> method will see more significant differences.<br><strong>RFE</strong>: <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6962931">6962931</a></p>
</blockquote>
</li>
<li><p>深入理解Java虚拟机中<code>3.2.2 可达性分析算法</code>写到</p>
<blockquote>
<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种： </p>
<p>·在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 </p>
<p>·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 </p>
<p>·<strong>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</strong></p>
</blockquote>
</li>
<li><p>R大说的</p>
<blockquote>
<p>常量池”如果说的是SymbolTable / StringTable，这俩table自身原本就一直在native memory里，是它们所引用的东西在哪里更有意思。上面说了，java7是把SymbolTable引用的Symbol移动到了native memory，而StringTable引用的java.lang.String实例则从PermGen移动到了普通Java heap。</p>
</blockquote>
</li>
<li><p>StringTable的创建源码</p>
<p>hotspot/src/share/vm/memory/universe.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jint <span class="title function_">universe_init</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UseSharedSpaces) &#123;</span><br><span class="line">    <span class="comment">// Read the data structures supporting the shared spaces (shared</span></span><br><span class="line">    <span class="comment">// system dictionary, symbol table, etc.).  After that, access to</span></span><br><span class="line">    <span class="comment">// the file (other than the mapped regions) is no longer needed, and</span></span><br><span class="line">    <span class="comment">// the file is closed. Closing the file does not affect the</span></span><br><span class="line">    <span class="comment">// currently mapped regions.</span></span><br><span class="line">    MetaspaceShared::initialize_shared_spaces();</span><br><span class="line">    StringTable::create_table();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    SymbolTable::create_table();</span><br><span class="line">    StringTable::create_table();</span><br><span class="line">    ClassLoader::create_package_info_table();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用链（jdk12）</p>
<p><img src="image-20220720175742728-16614058967029.png" alt="image-20220720175742728"></p>
<p>最终创建一个CHeap对象，不在 Java 的几个托管内存里，其实也就是native memory</p>
</li>
</ol>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，字符串常量池一直在nativememory中</p>
<p>而JDK1.7之后interned strings被移动到了堆内存中，而StringTable保存的是字符串的hashvalue以及字符串本身</p>
<p>另外，SymbolTable也在native memory中，至于SymbolTable的作用见<a href="https://hllvm-group.iteye.com/group/topic/26412#post-187861">https://hllvm-group.iteye.com/group/topic/26412#post-187861</a></p>
<blockquote>
<p>这些Utf8常量在HotSpot VM里以symbolOopDesc对象（下面简称symbol对象）来表现；它们可以通过一个全局的SymbolTable对象找到。注意：constantPool对象并不“包含”这些symbol对象，而只是引用着它们而已；或者说，constantPool对象只存了对symbol对象的引用，而没有存它们的内容。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/29352626/answer/44050736">https://www.zhihu.com/question/29352626/answer/44050736</a></p>
<blockquote>
<p>Symbol内嵌的存储不是char数组。如果要CONSTANT_String（String）引用了CONSTANT_Utf8（Symbol），那么ldc在初始化这个String对象的时候会从Symbol那边读取内容并创建对应的char[]以及String对象。</p>
</blockquote>
<blockquote>
<p>Symbols在JDK7和JDK8里都在native memory里，但不在Metaspace里。<br>Symbols在native memory里通过引用计数管理，同时有个全局的SymbolTable管理着所有Symbol。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>常量池</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
</search>
